import numpy as np
import cmath as cm

from .c_ij_matrix import *

# Среда ИЗОТРОПНАЯ.

# Следующая функция будет честно, по заданной матрице упругих модулей среды Cij, плотности среды и направлению
# в пространстве, будет составлять уравнение Кристоффеля и рассчитывать векторы поляризации волн, которые могут
# распространяться в данном направлении.

# на вход этой функции подаются аргументы в следующем порядке:

# c_ij - 6x6-матрица упругих модулей среды
# n - 3x1-матрица (т.е. вектор из трёх координат) - направление в пространстве

# на выходе этой функции будет:

# u - 3x3-матрица - матрица, столбцами которой будут вектора поляризации упругих волн в среде

# Поляризации поперечных волн будут таковы: первая из них лежит в плосоксти экрана, а вторая смотрит в экран на нас.
# Тройка us2,us1,up - правая.


def polarizations(c_ij1, n): # index "1" beside "c_ij" marks that this is a variable,
    # not a function defined in another module
    
    # задаём формат вывода
    u = np.array(0, dtype=complex)
    u.resize(3, 3)
    
    # находим весь тензор c_ijkl1:
    c_ijkl1 = c_ijkl(c_ij1) # the same index with the same purpose

    # Строим матрицу Кристоффеля Гik = c_ijkl1*nj*nl:
    Гik = np.array(0, dtype=complex)
    Гik.resize(3, 3)

    for i in range(3):
        for j in range(3):
            for k in range(3):
                for l in range(3):
                    Гik[i, k] = Гik[i, k] + c_ijkl1[i, j, k, l] * n[j] * n[l]
                    
    # И находим собственные векторы этой матрицы. Они и будут векторами поляризации.
    # Однако эти векторы будут в невесть каком порядке. Исправим это: отсортируем соственные числа по возрастанию:
    eigenvalues = np.linalg.eig(Гik)[0]
    I = np.argsort(eigenvalues)  # запоминаем перестановку
    
    polariz = np.linalg.eig(Гik)[1]  # отсюда будем брать векторы поляризвации.
    
    # поляризация продольной волны совпадает с направлением распространения волны
    u[:, 0] = polariz[:, I[2]]  # поляризация продольной волны
    if u[:, 0].dot(n) < 0:
        u[:, 0] = - u[:, 0]  # Продольная волна должна быть поляризована в направлении распространения.

    # может получиться так, что все три вектора поляризации будут направлены вдоль осей координат. В этом случае надо
    # директивно  задать "правильные" направления поляризаций.
    # В изотропной среде, с учётом особенностей нашей задачи, такая ситуация может возникнуть только при нормальном
    # падении:

    if abs(u[2, 0]) == 1: # если продольная волна поляризована по Z

        u[:, 1] = np.array([1, 0, 0])
        u[:, 2] = np.array([0, 1, 0])

        return u

    # поляризацию поперечной волны можно задать по-разному, но мы зададим так:

    if np.dot(polariz[:,I[0]], np.array([0, 0, 1])) == 0: # если собственный вектор, соответствующий самому маленькому
        # собственному числу, ортогонален вертикальному вектору, то он соответствует S2 (SH) - волне:

        u[:,1] = polariz[:,I[1]] #поляризация "первой" поперечной волны
        u[:,2] = polariz[:,I[0]] #поляризация "второй" поперечной волны


    else: #если же нет...

        u[:,1] = polariz[:,I[0]] #поляризация "первой" поперечной волны
        u[:,2] = polariz[:,I[1]] #поляризация "второй" поперечной волны

    # Осталось проверить последнее: не получается ли тройка S1, S2 и P левой. Заметим, что поляризация вектора P уже правильная. Будем
    # варьировать знак S2.

    if np.dot(u[:, 0], np.cross(u[:, 1], u[:, 2])) < 0:

        u[:, 2] = - u[:, 2]

    return u