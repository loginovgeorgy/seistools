import numpy as np  # отмечен, как "неиспользуемый" импорт. Это странно: библиотека используется в коде.
import cmath as cm

from .c_ij_matrix import *

# Функции в модуле написаны для 2,5-D модели: вектора и пространство трёхмерные, но вдоль оси Y ничего не меняется.
# Вектор нормали к фронту падающей волны лежит в плоскости XZ. Ориентация осей следующая:
# ось X направлена вправо вдоль экрана, ось Z - вниз вдоль экрана. Ось Y смотрит в экран на нас. Среда ИЗОТРОПНАЯ.

# Следующая функция будет честно, по заданной матрице упругих модулей среды Cij, плотности среды и направлению
# в пространстве, будет составлять уравнение Кристоффеля и рассчитывать векторы поляризации волн, которые могут
# распространяться в данном направлении.

# на вход этой функции подаются аргументы в следующем порядке:

# Cij - 6x6-матрица упругих модулей среды
# n - 3x1-матрица (т.е. вектор из трёх координат) - направление в пространстве

# на выходе этой функции будет:

# U - 3x3-матрица - матрица, столбцами которой будут вектора поляризации упругих волн в среде

# Поляризации поперечных волн будут таковы: первая из них лежит в плосоксти экрана, а вторая смотрит в экран на нас.
# Тройка Us2,Us1,Up - правая.


def polarizations(c_ij, n):
    
    # задаём формат вывода
    u = np.array(0, dtype=complex)
    u.resize(3, 3)
    
    # находим весь тензор Cijkl:
    c_ijkl1 = c_ijkl(c_ij)

    # Строим матрицу Кристоффеля Гik = Cijkl*pj*pl:
    Гik = np.array(0, dtype=complex)
    Гik.resize(3, 3)

    for i in range(3):
        for j in range(3):
            for k in range(3):
                for l in range(3):
                    Гik[i, k] = Гik[i, k] + c_ijkl1[i, j, k, l] * n[j] * n[l]
                    
#     И находим собственные векторы этой матрицы. Они и будут векторами поляризации.
# Однако эти векторы будут в невесть каком порядке. Исправим это: отсортируем соственные числа по возрастанию:
    eigenvalues = np.linalg.eig(Гik)[0]
    I = np.argsort(eigenvalues)  # запоминаем перестановку
    
    polarizations = np.linalg.eig(Гik)[1]  # отсюда будем брать векторы поляризвации.
    
#     поляризация продольной волны совпадает с направлением распространения волны
    u[:, 0] = polarizations[:, I[2]]  # поляризация продольной волны
    if u[:, 0].dot(n) < 0:
        u[:, 0] = - u[:, 0]  # Продольная волна должна быть поляризована в направлении распространения.
    
#     поляризацию поперечной волны можно задать по-разному, но мы зададим так:
    for i in range(2):
        if polarizations[:, I[i]][1] == 0:  # если Y-координата собственного вектора,
            #  соответствующего второму собственному числу, равна 0...
            u[:, 1] = polarizations[:, I[1]]  # поляризация "первой" поперечной волны.
            u[:, 2] = polarizations[:, I[0]]  # поляризация "второй" поперечной волны
            
        else:  # если же нет...
            u[:, 1] = polarizations[:, I[0]]  # поляризация "первой" поперечной волны.
            # "Минус" - чтобы выполнить наши соглашения об ориентации векторов.
            u[:, 2] = polarizations[:, I[1]]  # поляризация "второй" поперечной волны

    return u
